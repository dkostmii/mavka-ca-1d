взяти математика [отримати_цифри, отримати_значення, отримати_цикл]

дія обчислити_стан_клітинки(сусідство список<число>, правило число) число
  біти_правила список<число> = отримати_цифри(правило, 2, 2 ** сусідство.довжина)
  позиція_сусідства = отримати_значення(сусідство, 2)

  вернути біти_правила[позиція_сусідства]
кінець

дія отримати_сусідство(позиція число, стан список<число>, радіус число = 1) список<число>
  якщо !(радіус >= 1)
    впасти "Очікується, що радіус є рівна чи більший 1"
  кінець

  результат список<число> = []

  а = позиція - радіус
  б = позиція + радіус

  перебрати а..б як поз_сусіда
    результат.додати(отримати_цикл<число>(стан, поз_сусіда))
  кінець

  якщо результат.довжина != (2 * радіус + 1)
    впасти "Очікується, що довжина результату рівна 2 * радіус + 1"
  кінець

  вернути результат
кінець

дія обчислити_наступний_стан(попередній_стан список<число>, правило число) список<число>
  довжина = попередній_стан.довжина

  якщо !(довжина >= 1)
    впасти "Очікується, що довжина стану рівна чи більша 1"
  кінець

  результат список<число> = []

  а = 0
  б = довжина - 1

  перебрати а..б як позиція
    сусідство = отримати_сусідство(позиція, попередній_стан)
    результат.додати(обчислити_стан_клітинки(сусідство, правило))
  кінець

  вернути результат
кінець

дія надрукувати_стан(стан список<число>, жива текст = "К", мертва текст = "_")
  якщо !(стан.довжина >= 1)
    впасти "Очікується, що довжина стану рівна чи більша 1"
  кінець

  рядок = ""

  перебрати стан як клітинка
    якщо клітинка > 0
      рядок += жива

    інакше
      рядок += мертва
    кінець
  кінець

  друк(рядок)
кінець

дати обчислити_наступний_стан
дати надрукувати_стан
