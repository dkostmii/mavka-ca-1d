взяти допоміжне [список_обернути]

дія мод(ділене число, дільник число)
  вернути ((ділене % дільник) + дільник) % дільник
кінець

дія перевірити_систему_числення(система_числення число)
  якщо система_числення == 0 або система_числення == 1
    впасти "Очікується система числення, відмінна від 0 та 1"
  кінець
кінець

дія отримати_цифри(значення число, система_числення число, стала_ширина число = 0) список<число>
  перевірити_систему_числення(система_числення)

  результат = []
  поточне = значення

  поки поточне != 0
    результат.додати(мод(поточне, система_числення))
    поточне = поточне // система_числення
  кінець

  якщо результат.довжина < стала_ширина
    поки результат.довжина < стала_ширина
      результат.додати(0)
    кінець
  кінець

  вернути список_обернути<число>(результат)
кінець

дія отримати_значення(цифри список<число>, система_числення число) число
  перевірити_систему_числення(система_числення)

  результат = 0
  розвернуті_цифри = список_обернути(цифри)

  а = 0
  б = розвернуті_цифри.довжина - 1

  перебрати а..б як позиція
    цифра = розвернуті_цифри[позиція]

    степінь = система_числення ** позиція

    результат = результат + цифра * степінь
  кінець

  вернути результат
кінець

дія цикл(значення число, мін число, макс число) число
  якщо !(мін <= макс)
    впасти "Очікується, що мін <= макс"
  кінець

  вернути мод(значення, макс - мін + 1) + мін
кінець

дія отримати_цикл<Т>(послідовність список<Т>, відносна_позиція число) Т
  позиція = цикл(відносна_позиція, 0, послідовність.довжина - 1)

  вернути послідовність[позиція]
кінець

дати мод
дати отримати_цифри
дати отримати_значення
дати отримати_цикл
дати цикл
дати отримати_цикл
